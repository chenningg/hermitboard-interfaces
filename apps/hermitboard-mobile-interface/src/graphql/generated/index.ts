import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  SessionToken: any;
  Time: any;
  Void: any;
};

export type Account = Node & {
  __typename?: 'Account';
  authRoles: AuthRoleConnection;
  authType: AuthType;
  connections: ConnectionConnection;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  email: Scalars['String'];
  emailConfirmed: Scalars['Boolean'];
  friends: AccountConnection;
  id: Scalars['ID'];
  nickname: Scalars['String'];
  passwordUpdatedAt?: Maybe<Scalars['Time']>;
  portfolios: PortfolioConnection;
  profilePictureURL?: Maybe<Scalars['String']>;
  updatedAt: Scalars['Time'];
};


export type AccountAuthRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AuthRoleOrder>;
  where?: InputMaybe<AuthRoleWhereInput>;
};


export type AccountConnectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ConnectionOrder>;
};


export type AccountFriendsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountOrder>;
  where?: InputMaybe<AccountWhereInput>;
};


export type AccountPortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PortfolioOrder>;
  where?: InputMaybe<PortfolioWhereInput>;
};

/** A connection to a list of items. */
export type AccountConnection = {
  __typename?: 'AccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccountEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AccountEdge = {
  __typename?: 'AccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Account>;
};

/** Ordering options for Account connections */
export type AccountOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Accounts. */
  field: AccountOrderField;
};

/** Properties by which Account connections can be ordered. */
export enum AccountOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  Email = 'EMAIL',
  Nickname = 'NICKNAME',
  PasswordUpdatedAt = 'PASSWORD_UPDATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * AccountWhereInput is used for filtering Account objects.
 * Input was generated by ent.
 */
export type AccountWhereInput = {
  and?: InputMaybe<Array<AccountWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  /** email_confirmed field predicates */
  emailConfirmed?: InputMaybe<Scalars['Boolean']>;
  emailConfirmedNEQ?: InputMaybe<Scalars['Boolean']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** auth_roles edge predicates */
  hasAuthRoles?: InputMaybe<Scalars['Boolean']>;
  hasAuthRolesWith?: InputMaybe<Array<AuthRoleWhereInput>>;
  /** auth_type edge predicates */
  hasAuthType?: InputMaybe<Scalars['Boolean']>;
  hasAuthTypeWith?: InputMaybe<Array<AuthTypeWhereInput>>;
  /** friends edge predicates */
  hasFriends?: InputMaybe<Scalars['Boolean']>;
  hasFriendsWith?: InputMaybe<Array<AccountWhereInput>>;
  /** portfolios edge predicates */
  hasPortfolios?: InputMaybe<Scalars['Boolean']>;
  hasPortfoliosWith?: InputMaybe<Array<PortfolioWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** nickname field predicates */
  nickname?: InputMaybe<Scalars['String']>;
  nicknameContains?: InputMaybe<Scalars['String']>;
  nicknameContainsFold?: InputMaybe<Scalars['String']>;
  nicknameEqualFold?: InputMaybe<Scalars['String']>;
  nicknameGT?: InputMaybe<Scalars['String']>;
  nicknameGTE?: InputMaybe<Scalars['String']>;
  nicknameHasPrefix?: InputMaybe<Scalars['String']>;
  nicknameHasSuffix?: InputMaybe<Scalars['String']>;
  nicknameIn?: InputMaybe<Array<Scalars['String']>>;
  nicknameLT?: InputMaybe<Scalars['String']>;
  nicknameLTE?: InputMaybe<Scalars['String']>;
  nicknameNEQ?: InputMaybe<Scalars['String']>;
  nicknameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<AccountWhereInput>;
  or?: InputMaybe<Array<AccountWhereInput>>;
  /** password_updated_at field predicates */
  passwordUpdatedAt?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtGT?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtGTE?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  passwordUpdatedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  passwordUpdatedAtLT?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtLTE?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtNEQ?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  passwordUpdatedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Asset = Node & {
  __typename?: 'Asset';
  assetClass: AssetClass;
  createdAt: Scalars['Time'];
  cryptocurrency?: Maybe<Cryptocurrency>;
  dailyAssetPrices: DailyAssetPriceConnection;
  deletedAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  updatedAt: Scalars['Time'];
};


export type AssetDailyAssetPricesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DailyAssetPriceOrder>;
};

export type AssetClass = Node & {
  __typename?: 'AssetClass';
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  updatedAt: Scalars['Time'];
  value: AssetClassValue;
};

/** A connection to a list of items. */
export type AssetClassConnection = {
  __typename?: 'AssetClassConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssetClassEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AssetClassEdge = {
  __typename?: 'AssetClassEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<AssetClass>;
};

/** Ordering options for AssetClass connections */
export type AssetClassOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AssetClasses. */
  field: AssetClassOrderField;
};

/** Properties by which AssetClass connections can be ordered. */
export enum AssetClassOrderField {
  AssetClassValue = 'ASSET_CLASS_VALUE',
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/** AssetClassValue is enum for the field value */
export enum AssetClassValue {
  CashOrCashEquivalent = 'CASH_OR_CASH_EQUIVALENT',
  Commodity = 'COMMODITY',
  Cryptocurrency = 'CRYPTOCURRENCY',
  Equity = 'EQUITY',
  FixedIncome = 'FIXED_INCOME',
  Future = 'FUTURE',
  RealEstate = 'REAL_ESTATE'
}

/**
 * AssetClassWhereInput is used for filtering AssetClass objects.
 * Input was generated by ent.
 */
export type AssetClassWhereInput = {
  and?: InputMaybe<Array<AssetClassWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<AssetClassWhereInput>;
  or?: InputMaybe<Array<AssetClassWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** value field predicates */
  value?: InputMaybe<AssetClassValue>;
  valueIn?: InputMaybe<Array<AssetClassValue>>;
  valueNEQ?: InputMaybe<AssetClassValue>;
  valueNotIn?: InputMaybe<Array<AssetClassValue>>;
};

/** A connection to a list of items. */
export type AssetConnection = {
  __typename?: 'AssetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssetEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AssetEdge = {
  __typename?: 'AssetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Asset>;
};

/** Ordering options for Asset connections */
export type AssetOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Assets. */
  field: AssetOrderField;
};

/** Properties by which Asset connections can be ordered. */
export enum AssetOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * AssetWhereInput is used for filtering Asset objects.
 * Input was generated by ent.
 */
export type AssetWhereInput = {
  and?: InputMaybe<Array<AssetWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** asset_class edge predicates */
  hasAssetClass?: InputMaybe<Scalars['Boolean']>;
  hasAssetClassWith?: InputMaybe<Array<AssetClassWhereInput>>;
  /** cryptocurrency edge predicates */
  hasCryptocurrency?: InputMaybe<Scalars['Boolean']>;
  hasCryptocurrencyWith?: InputMaybe<Array<CryptocurrencyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<AssetWhereInput>;
  or?: InputMaybe<Array<AssetWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type AuthRole = Node & {
  __typename?: 'AuthRole';
  accounts: AccountConnection;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  staffAccounts: StaffAccountConnection;
  updatedAt: Scalars['Time'];
  value: AuthRoleValue;
};


export type AuthRoleAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountOrder>;
};


export type AuthRoleStaffAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StaffAccountOrder>;
};

/** A connection to a list of items. */
export type AuthRoleConnection = {
  __typename?: 'AuthRoleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuthRoleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AuthRoleEdge = {
  __typename?: 'AuthRoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<AuthRole>;
};

/** Ordering options for AuthRole connections */
export type AuthRoleOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AuthRoles. */
  field: AuthRoleOrderField;
};

/** Properties by which AuthRole connections can be ordered. */
export enum AuthRoleOrderField {
  AuthRoleValue = 'AUTH_ROLE_VALUE',
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/** AuthRoleValue is enum for the field value */
export enum AuthRoleValue {
  Admin = 'ADMIN',
  Demo = 'DEMO',
  Enterprise = 'ENTERPRISE',
  Free = 'FREE',
  Plus = 'PLUS',
  Pro = 'PRO',
  SuperAdmin = 'SUPER_ADMIN',
  Support = 'SUPPORT'
}

/**
 * AuthRoleWhereInput is used for filtering AuthRole objects.
 * Input was generated by ent.
 */
export type AuthRoleWhereInput = {
  and?: InputMaybe<Array<AuthRoleWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<AuthRoleWhereInput>;
  or?: InputMaybe<Array<AuthRoleWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** value field predicates */
  value?: InputMaybe<AuthRoleValue>;
  valueIn?: InputMaybe<Array<AuthRoleValue>>;
  valueNEQ?: InputMaybe<AuthRoleValue>;
  valueNotIn?: InputMaybe<Array<AuthRoleValue>>;
};

export type AuthType = Node & {
  __typename?: 'AuthType';
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  updatedAt: Scalars['Time'];
  value: AuthTypeValue;
};

/** A connection to a list of items. */
export type AuthTypeConnection = {
  __typename?: 'AuthTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuthTypeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AuthTypeEdge = {
  __typename?: 'AuthTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<AuthType>;
};

/** Ordering options for AuthType connections */
export type AuthTypeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AuthTypes. */
  field: AuthTypeOrderField;
};

/** Properties by which AuthType connections can be ordered. */
export enum AuthTypeOrderField {
  AuthTypeValue = 'AUTH_TYPE_VALUE',
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/** AuthTypeValue is enum for the field value */
export enum AuthTypeValue {
  Apple = 'APPLE',
  Facebook = 'FACEBOOK',
  Google = 'GOOGLE',
  Local = 'LOCAL'
}

/**
 * AuthTypeWhereInput is used for filtering AuthType objects.
 * Input was generated by ent.
 */
export type AuthTypeWhereInput = {
  and?: InputMaybe<Array<AuthTypeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<AuthTypeWhereInput>;
  or?: InputMaybe<Array<AuthTypeWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** value field predicates */
  value?: InputMaybe<AuthTypeValue>;
  valueIn?: InputMaybe<Array<AuthTypeValue>>;
  valueNEQ?: InputMaybe<AuthTypeValue>;
  valueNotIn?: InputMaybe<Array<AuthTypeValue>>;
};

export type Blockchain = Node & {
  __typename?: 'Blockchain';
  chainID?: Maybe<Scalars['Int']>;
  createdAt: Scalars['Time'];
  cryptocurrencies: CryptocurrencyConnection;
  deletedAt?: Maybe<Scalars['Time']>;
  icon?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  symbol: Scalars['String'];
  transactions: TransactionConnection;
  updatedAt: Scalars['Time'];
};


export type BlockchainCryptocurrenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CryptocurrencyOrder>;
};


export type BlockchainTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionOrder>;
};

/** A connection to a list of items. */
export type BlockchainConnection = {
  __typename?: 'BlockchainConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlockchainEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BlockchainEdge = {
  __typename?: 'BlockchainEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Blockchain>;
};

/** Ordering options for Blockchain connections */
export type BlockchainOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Blockchains. */
  field: BlockchainOrderField;
};

/** Properties by which Blockchain connections can be ordered. */
export enum BlockchainOrderField {
  ChainId = 'CHAIN_ID',
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  Name = 'NAME',
  Symbol = 'SYMBOL',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * BlockchainWhereInput is used for filtering Blockchain objects.
 * Input was generated by ent.
 */
export type BlockchainWhereInput = {
  and?: InputMaybe<Array<BlockchainWhereInput>>;
  /** chain_id field predicates */
  chainID?: InputMaybe<Scalars['Int']>;
  chainIDGT?: InputMaybe<Scalars['Int']>;
  chainIDGTE?: InputMaybe<Scalars['Int']>;
  chainIDIn?: InputMaybe<Array<Scalars['Int']>>;
  chainIDIsNil?: InputMaybe<Scalars['Boolean']>;
  chainIDLT?: InputMaybe<Scalars['Int']>;
  chainIDLTE?: InputMaybe<Scalars['Int']>;
  chainIDNEQ?: InputMaybe<Scalars['Int']>;
  chainIDNotIn?: InputMaybe<Array<Scalars['Int']>>;
  chainIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<BlockchainWhereInput>;
  or?: InputMaybe<Array<BlockchainWhereInput>>;
  /** symbol field predicates */
  symbol?: InputMaybe<Scalars['String']>;
  symbolContains?: InputMaybe<Scalars['String']>;
  symbolContainsFold?: InputMaybe<Scalars['String']>;
  symbolEqualFold?: InputMaybe<Scalars['String']>;
  symbolGT?: InputMaybe<Scalars['String']>;
  symbolGTE?: InputMaybe<Scalars['String']>;
  symbolHasPrefix?: InputMaybe<Scalars['String']>;
  symbolHasSuffix?: InputMaybe<Scalars['String']>;
  symbolIn?: InputMaybe<Array<Scalars['String']>>;
  symbolLT?: InputMaybe<Scalars['String']>;
  symbolLTE?: InputMaybe<Scalars['String']>;
  symbolNEQ?: InputMaybe<Scalars['String']>;
  symbolNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Connection = Node & {
  __typename?: 'Connection';
  accessToken: Scalars['String'];
  account: Account;
  accountID: Scalars['ID'];
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  portfolios: PortfolioConnection;
  refreshToken?: Maybe<Scalars['String']>;
  source: Source;
  sourceID: Scalars['ID'];
  updatedAt: Scalars['Time'];
};


export type ConnectionPortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PortfolioOrder>;
};

/** A connection to a list of items. */
export type ConnectionConnection = {
  __typename?: 'ConnectionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConnectionEdge = {
  __typename?: 'ConnectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Connection>;
};

/** Ordering options for Connection connections */
export type ConnectionOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Connections. */
  field: ConnectionOrderField;
};

/** Properties by which Connection connections can be ordered. */
export enum ConnectionOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * ConnectionWhereInput is used for filtering Connection objects.
 * Input was generated by ent.
 */
export type ConnectionWhereInput = {
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['ID']>;
  accountIDContains?: InputMaybe<Scalars['ID']>;
  accountIDContainsFold?: InputMaybe<Scalars['ID']>;
  accountIDEqualFold?: InputMaybe<Scalars['ID']>;
  accountIDGT?: InputMaybe<Scalars['ID']>;
  accountIDGTE?: InputMaybe<Scalars['ID']>;
  accountIDHasPrefix?: InputMaybe<Scalars['ID']>;
  accountIDHasSuffix?: InputMaybe<Scalars['ID']>;
  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;
  accountIDLT?: InputMaybe<Scalars['ID']>;
  accountIDLTE?: InputMaybe<Scalars['ID']>;
  accountIDNEQ?: InputMaybe<Scalars['ID']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  and?: InputMaybe<Array<ConnectionWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;
  /** source edge predicates */
  hasSource?: InputMaybe<Scalars['Boolean']>;
  hasSourceWith?: InputMaybe<Array<SourceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ConnectionWhereInput>;
  or?: InputMaybe<Array<ConnectionWhereInput>>;
  /** source_id field predicates */
  sourceID?: InputMaybe<Scalars['ID']>;
  sourceIDContains?: InputMaybe<Scalars['ID']>;
  sourceIDContainsFold?: InputMaybe<Scalars['ID']>;
  sourceIDEqualFold?: InputMaybe<Scalars['ID']>;
  sourceIDGT?: InputMaybe<Scalars['ID']>;
  sourceIDGTE?: InputMaybe<Scalars['ID']>;
  sourceIDHasPrefix?: InputMaybe<Scalars['ID']>;
  sourceIDHasSuffix?: InputMaybe<Scalars['ID']>;
  sourceIDIn?: InputMaybe<Array<Scalars['ID']>>;
  sourceIDLT?: InputMaybe<Scalars['ID']>;
  sourceIDLTE?: InputMaybe<Scalars['ID']>;
  sourceIDNEQ?: InputMaybe<Scalars['ID']>;
  sourceIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

/**
 * CreateAccountInput is used for create Account object.
 * Input was generated by ent.
 */
export type CreateAccountInput = {
  authRoleIDs: Array<Scalars['ID']>;
  authTypeID: Scalars['ID'];
  email: Scalars['String'];
  nickname: Scalars['String'];
  password?: InputMaybe<Scalars['String']>;
};

export type CreateAccountPayload = {
  __typename?: 'CreateAccountPayload';
  account: Account;
  session: Session;
};

/**
 * CreateAssetClassInput is used for create AssetClass object.
 * Input was generated by ent.
 */
export type CreateAssetClassInput = {
  description?: InputMaybe<Scalars['String']>;
  value: AssetClassValue;
};

/**
 * CreateAuthRoleInput is used for create AuthRole object.
 * Input was generated by ent.
 */
export type CreateAuthRoleInput = {
  description?: InputMaybe<Scalars['String']>;
  value: AuthRoleValue;
};

/**
 * CreateAuthTypeInput is used for create AuthType object.
 * Input was generated by ent.
 */
export type CreateAuthTypeInput = {
  description?: InputMaybe<Scalars['String']>;
  value: AuthTypeValue;
};

/**
 * CreateBlockchainInput is used for create Blockchain object.
 * Input was generated by ent.
 */
export type CreateBlockchainInput = {
  chainID?: InputMaybe<Scalars['Int']>;
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  symbol: Scalars['String'];
};

/**
 * CreateConnectionInput is used for create Connection object.
 * Input was generated by ent.
 */
export type CreateConnectionInput = {
  accessToken: Scalars['String'];
  name: Scalars['String'];
  portfolioIDs?: InputMaybe<Array<Scalars['ID']>>;
  refreshToken?: InputMaybe<Scalars['String']>;
  sourceID: Scalars['ID'];
};

/**
 * CreateCryptocurrencyInput is used for create Cryptocurrency object.
 * Input was generated by ent.
 */
export type CreateCryptocurrencyInput = {
  assetID: Scalars['ID'];
  blockchainIDs: Array<Scalars['ID']>;
  /** A url to the image icon for this cryptocurrency. */
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  symbol: Scalars['String'];
};

/**
 * CreateDailyAssetPriceInput is used for create DailyAssetPrice object.
 * Input was generated by ent.
 */
export type CreateDailyAssetPriceInput = {
  adjustedClose: Scalars['Float'];
  assetID: Scalars['ID'];
  close?: InputMaybe<Scalars['Float']>;
  high?: InputMaybe<Scalars['Float']>;
  low?: InputMaybe<Scalars['Float']>;
  open?: InputMaybe<Scalars['Float']>;
  time: Scalars['Time'];
};

/**
 * CreateExchangeInput is used for create Exchange object.
 * Input was generated by ent.
 */
export type CreateExchangeInput = {
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  /** A url to the exchange site. */
  url?: InputMaybe<Scalars['String']>;
};

/**
 * CreatePortfolioInput is used for create Portfolio object.
 * Input was generated by ent.
 */
export type CreatePortfolioInput = {
  connectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Whether this portfolio is visible to others. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Whether this portfolio is visible to the owner. */
  isVisible?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};

/**
 * CreateSourceInput is used for create Source object.
 * Input was generated by ent.
 */
export type CreateSourceInput = {
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  sourceTypeID: Scalars['ID'];
};

/**
 * CreateSourceTypeInput is used for create SourceType object.
 * Input was generated by ent.
 */
export type CreateSourceTypeInput = {
  description?: InputMaybe<Scalars['String']>;
  value: SourceTypeValue;
};

/**
 * CreateStaffAccountInput is used for create StaffAccount object.
 * Input was generated by ent.
 */
export type CreateStaffAccountInput = {
  authRoleIDs?: InputMaybe<Array<Scalars['ID']>>;
  authTypeID: Scalars['ID'];
  email: Scalars['String'];
  nickname: Scalars['String'];
  password?: InputMaybe<Scalars['String']>;
};

export type CreateStaffAccountPayload = {
  __typename?: 'CreateStaffAccountPayload';
  session: Session;
  staffAccount: StaffAccount;
};

/**
 * CreateTransactionInput is used for create Transaction object.
 * Input was generated by ent.
 */
export type CreateTransactionInput = {
  baseAssetID: Scalars['ID'];
  blockchainID?: InputMaybe<Scalars['ID']>;
  exchangeID: Scalars['ID'];
  portfolioID: Scalars['ID'];
  pricePerUnit: Scalars['Float'];
  quoteAssetID?: InputMaybe<Scalars['ID']>;
  time: Scalars['Time'];
  transactionTypeID: Scalars['ID'];
  units: Scalars['Int'];
};

/**
 * CreateTransactionTypeInput is used for create TransactionType object.
 * Input was generated by ent.
 */
export type CreateTransactionTypeInput = {
  description?: InputMaybe<Scalars['String']>;
  value: TransactionTypeValue;
};

export type Cryptocurrency = Node & {
  __typename?: 'Cryptocurrency';
  asset: Asset;
  assetID: Scalars['ID'];
  blockchains: BlockchainConnection;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  /** A url to the image icon for this cryptocurrency. */
  icon?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  symbol: Scalars['String'];
  updatedAt: Scalars['Time'];
};


export type CryptocurrencyBlockchainsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BlockchainOrder>;
  where?: InputMaybe<BlockchainWhereInput>;
};

/** A connection to a list of items. */
export type CryptocurrencyConnection = {
  __typename?: 'CryptocurrencyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CryptocurrencyEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CryptocurrencyEdge = {
  __typename?: 'CryptocurrencyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Cryptocurrency>;
};

/** Ordering options for Cryptocurrency connections */
export type CryptocurrencyOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Cryptocurrencies. */
  field: CryptocurrencyOrderField;
};

/** Properties by which Cryptocurrency connections can be ordered. */
export enum CryptocurrencyOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  Name = 'NAME',
  Symbol = 'SYMBOL',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * CryptocurrencyWhereInput is used for filtering Cryptocurrency objects.
 * Input was generated by ent.
 */
export type CryptocurrencyWhereInput = {
  and?: InputMaybe<Array<CryptocurrencyWhereInput>>;
  /** asset_id field predicates */
  assetID?: InputMaybe<Scalars['ID']>;
  assetIDContains?: InputMaybe<Scalars['ID']>;
  assetIDContainsFold?: InputMaybe<Scalars['ID']>;
  assetIDEqualFold?: InputMaybe<Scalars['ID']>;
  assetIDGT?: InputMaybe<Scalars['ID']>;
  assetIDGTE?: InputMaybe<Scalars['ID']>;
  assetIDHasPrefix?: InputMaybe<Scalars['ID']>;
  assetIDHasSuffix?: InputMaybe<Scalars['ID']>;
  assetIDIn?: InputMaybe<Array<Scalars['ID']>>;
  assetIDLT?: InputMaybe<Scalars['ID']>;
  assetIDLTE?: InputMaybe<Scalars['ID']>;
  assetIDNEQ?: InputMaybe<Scalars['ID']>;
  assetIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** asset edge predicates */
  hasAsset?: InputMaybe<Scalars['Boolean']>;
  hasAssetWith?: InputMaybe<Array<AssetWhereInput>>;
  /** blockchains edge predicates */
  hasBlockchains?: InputMaybe<Scalars['Boolean']>;
  hasBlockchainsWith?: InputMaybe<Array<BlockchainWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CryptocurrencyWhereInput>;
  or?: InputMaybe<Array<CryptocurrencyWhereInput>>;
  /** symbol field predicates */
  symbol?: InputMaybe<Scalars['String']>;
  symbolContains?: InputMaybe<Scalars['String']>;
  symbolContainsFold?: InputMaybe<Scalars['String']>;
  symbolEqualFold?: InputMaybe<Scalars['String']>;
  symbolGT?: InputMaybe<Scalars['String']>;
  symbolGTE?: InputMaybe<Scalars['String']>;
  symbolHasPrefix?: InputMaybe<Scalars['String']>;
  symbolHasSuffix?: InputMaybe<Scalars['String']>;
  symbolIn?: InputMaybe<Array<Scalars['String']>>;
  symbolLT?: InputMaybe<Scalars['String']>;
  symbolLTE?: InputMaybe<Scalars['String']>;
  symbolNEQ?: InputMaybe<Scalars['String']>;
  symbolNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type DailyAssetPrice = Node & {
  __typename?: 'DailyAssetPrice';
  adjustedClose: Scalars['Float'];
  asset: Asset;
  assetID: Scalars['ID'];
  close?: Maybe<Scalars['Float']>;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  high?: Maybe<Scalars['Float']>;
  id: Scalars['ID'];
  low?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  time: Scalars['Time'];
  updatedAt: Scalars['Time'];
};

/** A connection to a list of items. */
export type DailyAssetPriceConnection = {
  __typename?: 'DailyAssetPriceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DailyAssetPriceEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DailyAssetPriceEdge = {
  __typename?: 'DailyAssetPriceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DailyAssetPrice>;
};

/** Ordering options for DailyAssetPrice connections */
export type DailyAssetPriceOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order DailyAssetPrices. */
  field: DailyAssetPriceOrderField;
};

/** Properties by which DailyAssetPrice connections can be ordered. */
export enum DailyAssetPriceOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  Time = 'TIME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * DailyAssetPriceWhereInput is used for filtering DailyAssetPrice objects.
 * Input was generated by ent.
 */
export type DailyAssetPriceWhereInput = {
  /** adjusted_close field predicates */
  adjustedClose?: InputMaybe<Scalars['Float']>;
  adjustedCloseGT?: InputMaybe<Scalars['Float']>;
  adjustedCloseGTE?: InputMaybe<Scalars['Float']>;
  adjustedCloseIn?: InputMaybe<Array<Scalars['Float']>>;
  adjustedCloseLT?: InputMaybe<Scalars['Float']>;
  adjustedCloseLTE?: InputMaybe<Scalars['Float']>;
  adjustedCloseNEQ?: InputMaybe<Scalars['Float']>;
  adjustedCloseNotIn?: InputMaybe<Array<Scalars['Float']>>;
  and?: InputMaybe<Array<DailyAssetPriceWhereInput>>;
  /** asset_id field predicates */
  assetID?: InputMaybe<Scalars['ID']>;
  assetIDContains?: InputMaybe<Scalars['ID']>;
  assetIDContainsFold?: InputMaybe<Scalars['ID']>;
  assetIDEqualFold?: InputMaybe<Scalars['ID']>;
  assetIDGT?: InputMaybe<Scalars['ID']>;
  assetIDGTE?: InputMaybe<Scalars['ID']>;
  assetIDHasPrefix?: InputMaybe<Scalars['ID']>;
  assetIDHasSuffix?: InputMaybe<Scalars['ID']>;
  assetIDIn?: InputMaybe<Array<Scalars['ID']>>;
  assetIDLT?: InputMaybe<Scalars['ID']>;
  assetIDLTE?: InputMaybe<Scalars['ID']>;
  assetIDNEQ?: InputMaybe<Scalars['ID']>;
  assetIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** close field predicates */
  close?: InputMaybe<Scalars['Float']>;
  closeGT?: InputMaybe<Scalars['Float']>;
  closeGTE?: InputMaybe<Scalars['Float']>;
  closeIn?: InputMaybe<Array<Scalars['Float']>>;
  closeIsNil?: InputMaybe<Scalars['Boolean']>;
  closeLT?: InputMaybe<Scalars['Float']>;
  closeLTE?: InputMaybe<Scalars['Float']>;
  closeNEQ?: InputMaybe<Scalars['Float']>;
  closeNotIn?: InputMaybe<Array<Scalars['Float']>>;
  closeNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** asset edge predicates */
  hasAsset?: InputMaybe<Scalars['Boolean']>;
  hasAssetWith?: InputMaybe<Array<AssetWhereInput>>;
  /** high field predicates */
  high?: InputMaybe<Scalars['Float']>;
  highGT?: InputMaybe<Scalars['Float']>;
  highGTE?: InputMaybe<Scalars['Float']>;
  highIn?: InputMaybe<Array<Scalars['Float']>>;
  highIsNil?: InputMaybe<Scalars['Boolean']>;
  highLT?: InputMaybe<Scalars['Float']>;
  highLTE?: InputMaybe<Scalars['Float']>;
  highNEQ?: InputMaybe<Scalars['Float']>;
  highNotIn?: InputMaybe<Array<Scalars['Float']>>;
  highNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** low field predicates */
  low?: InputMaybe<Scalars['Float']>;
  lowGT?: InputMaybe<Scalars['Float']>;
  lowGTE?: InputMaybe<Scalars['Float']>;
  lowIn?: InputMaybe<Array<Scalars['Float']>>;
  lowIsNil?: InputMaybe<Scalars['Boolean']>;
  lowLT?: InputMaybe<Scalars['Float']>;
  lowLTE?: InputMaybe<Scalars['Float']>;
  lowNEQ?: InputMaybe<Scalars['Float']>;
  lowNotIn?: InputMaybe<Array<Scalars['Float']>>;
  lowNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<DailyAssetPriceWhereInput>;
  /** open field predicates */
  open?: InputMaybe<Scalars['Float']>;
  openGT?: InputMaybe<Scalars['Float']>;
  openGTE?: InputMaybe<Scalars['Float']>;
  openIn?: InputMaybe<Array<Scalars['Float']>>;
  openIsNil?: InputMaybe<Scalars['Boolean']>;
  openLT?: InputMaybe<Scalars['Float']>;
  openLTE?: InputMaybe<Scalars['Float']>;
  openNEQ?: InputMaybe<Scalars['Float']>;
  openNotIn?: InputMaybe<Array<Scalars['Float']>>;
  openNotNil?: InputMaybe<Scalars['Boolean']>;
  or?: InputMaybe<Array<DailyAssetPriceWhereInput>>;
  /** time field predicates */
  time?: InputMaybe<Scalars['Time']>;
  timeGT?: InputMaybe<Scalars['Time']>;
  timeGTE?: InputMaybe<Scalars['Time']>;
  timeIn?: InputMaybe<Array<Scalars['Time']>>;
  timeLT?: InputMaybe<Scalars['Time']>;
  timeLTE?: InputMaybe<Scalars['Time']>;
  timeNEQ?: InputMaybe<Scalars['Time']>;
  timeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type DeleteConnectionInput = {
  id: Scalars['ID'];
};

export type DeletePortfolioInput = {
  id: Scalars['ID'];
};

export type Exchange = Node & {
  __typename?: 'Exchange';
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  icon?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  transactions: TransactionConnection;
  updatedAt: Scalars['Time'];
  /** A url to the exchange site. */
  url?: Maybe<Scalars['String']>;
};


export type ExchangeTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionOrder>;
  where?: InputMaybe<TransactionWhereInput>;
};

/** A connection to a list of items. */
export type ExchangeConnection = {
  __typename?: 'ExchangeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExchangeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ExchangeEdge = {
  __typename?: 'ExchangeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Exchange>;
};

/** Ordering options for Exchange connections */
export type ExchangeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Exchanges. */
  field: ExchangeOrderField;
};

/** Properties by which Exchange connections can be ordered. */
export enum ExchangeOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * ExchangeWhereInput is used for filtering Exchange objects.
 * Input was generated by ent.
 */
export type ExchangeWhereInput = {
  and?: InputMaybe<Array<ExchangeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** transactions edge predicates */
  hasTransactions?: InputMaybe<Scalars['Boolean']>;
  hasTransactionsWith?: InputMaybe<Array<TransactionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ExchangeWhereInput>;
  or?: InputMaybe<Array<ExchangeWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']>;
  urlContains?: InputMaybe<Scalars['String']>;
  urlContainsFold?: InputMaybe<Scalars['String']>;
  urlEqualFold?: InputMaybe<Scalars['String']>;
  urlGT?: InputMaybe<Scalars['String']>;
  urlGTE?: InputMaybe<Scalars['String']>;
  urlHasPrefix?: InputMaybe<Scalars['String']>;
  urlHasSuffix?: InputMaybe<Scalars['String']>;
  urlIn?: InputMaybe<Array<Scalars['String']>>;
  urlIsNil?: InputMaybe<Scalars['Boolean']>;
  urlLT?: InputMaybe<Scalars['String']>;
  urlLTE?: InputMaybe<Scalars['String']>;
  urlNEQ?: InputMaybe<Scalars['String']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']>>;
  urlNotNil?: InputMaybe<Scalars['Boolean']>;
};

export type LoginToAccountInput = {
  password: Scalars['String'];
  username: Scalars['String'];
};

export type LoginToAccountPayload = {
  __typename?: 'LoginToAccountPayload';
  account: Account;
  session: Session;
};

export type LoginToStaffAccountInput = {
  password: Scalars['String'];
  username: Scalars['String'];
};

export type LoginToStaffAccountPayload = {
  __typename?: 'LoginToStaffAccountPayload';
  session: Session;
  staffAccount: StaffAccount;
};

export type Mutation = {
  __typename?: 'Mutation';
  createAccount: CreateAccountPayload;
  createConnection: Connection;
  createPortfolio: Portfolio;
  createStaffAccount: CreateStaffAccountPayload;
  loginToAccount: LoginToAccountPayload;
  loginToStaffAccount: LoginToStaffAccountPayload;
  logout?: Maybe<Scalars['Void']>;
  updateConnection: Connection;
  updatePortfolio: Portfolio;
};


export type MutationCreateAccountArgs = {
  input: CreateAccountInput;
};


export type MutationCreateConnectionArgs = {
  input: CreateConnectionInput;
};


export type MutationCreatePortfolioArgs = {
  input: CreatePortfolioInput;
};


export type MutationCreateStaffAccountArgs = {
  input: CreateStaffAccountInput;
};


export type MutationLoginToAccountArgs = {
  input: LoginToAccountInput;
};


export type MutationLoginToStaffAccountArgs = {
  input: LoginToStaffAccountInput;
};


export type MutationUpdateConnectionArgs = {
  id: Scalars['ID'];
  input: UpdateConnectionInput;
};


export type MutationUpdatePortfolioArgs = {
  id: Scalars['ID'];
  input: UpdatePortfolioInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Portfolio = Node & {
  __typename?: 'Portfolio';
  account: Account;
  accountID: Scalars['ID'];
  connections: ConnectionConnection;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  /** Whether this portfolio is visible to others. */
  isPublic: Scalars['Boolean'];
  /** Whether this portfolio is visible to the owner. */
  isVisible: Scalars['Boolean'];
  name: Scalars['String'];
  transactions: TransactionConnection;
  updatedAt: Scalars['Time'];
};


export type PortfolioConnectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ConnectionOrder>;
  where?: InputMaybe<ConnectionWhereInput>;
};


export type PortfolioTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionOrder>;
};

/** A connection to a list of items. */
export type PortfolioConnection = {
  __typename?: 'PortfolioConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PortfolioEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PortfolioEdge = {
  __typename?: 'PortfolioEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Portfolio>;
};

/** Ordering options for Portfolio connections */
export type PortfolioOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Portfolios. */
  field: PortfolioOrderField;
};

/** Properties by which Portfolio connections can be ordered. */
export enum PortfolioOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  IsPublic = 'IS_PUBLIC',
  IsVisible = 'IS_VISIBLE',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * PortfolioWhereInput is used for filtering Portfolio objects.
 * Input was generated by ent.
 */
export type PortfolioWhereInput = {
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['ID']>;
  accountIDContains?: InputMaybe<Scalars['ID']>;
  accountIDContainsFold?: InputMaybe<Scalars['ID']>;
  accountIDEqualFold?: InputMaybe<Scalars['ID']>;
  accountIDGT?: InputMaybe<Scalars['ID']>;
  accountIDGTE?: InputMaybe<Scalars['ID']>;
  accountIDHasPrefix?: InputMaybe<Scalars['ID']>;
  accountIDHasSuffix?: InputMaybe<Scalars['ID']>;
  accountIDIn?: InputMaybe<Array<Scalars['ID']>>;
  accountIDLT?: InputMaybe<Scalars['ID']>;
  accountIDLTE?: InputMaybe<Scalars['ID']>;
  accountIDNEQ?: InputMaybe<Scalars['ID']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  and?: InputMaybe<Array<PortfolioWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** account edge predicates */
  hasAccount?: InputMaybe<Scalars['Boolean']>;
  hasAccountWith?: InputMaybe<Array<AccountWhereInput>>;
  /** connections edge predicates */
  hasConnections?: InputMaybe<Scalars['Boolean']>;
  hasConnectionsWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** is_public field predicates */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  isPublicNEQ?: InputMaybe<Scalars['Boolean']>;
  /** is_visible field predicates */
  isVisible?: InputMaybe<Scalars['Boolean']>;
  isVisibleNEQ?: InputMaybe<Scalars['Boolean']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<PortfolioWhereInput>;
  or?: InputMaybe<Array<PortfolioWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Query = {
  __typename?: 'Query';
  accounts: AccountConnection;
  assetClasses: AssetClassConnection;
  assets: AssetConnection;
  authRoles: AuthRoleConnection;
  authTypes: AuthTypeConnection;
  blockchains: BlockchainConnection;
  connections: ConnectionConnection;
  cryptocurrencies: CryptocurrencyConnection;
  dailyAssetPrices: DailyAssetPriceConnection;
  exchanges: ExchangeConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  portfolios: PortfolioConnection;
  sourceTypes: SourceTypeConnection;
  sources: SourceConnection;
  staffAccounts: StaffAccountConnection;
  transactionTypes: TransactionTypeConnection;
  transactions: TransactionConnection;
};


export type QueryAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountOrder>;
  where?: InputMaybe<AccountWhereInput>;
};


export type QueryAssetClassesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AssetClassOrder>;
  where?: InputMaybe<AssetClassWhereInput>;
};


export type QueryAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AssetOrder>;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryAuthRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AuthRoleOrder>;
  where?: InputMaybe<AuthRoleWhereInput>;
};


export type QueryAuthTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AuthTypeOrder>;
  where?: InputMaybe<AuthTypeWhereInput>;
};


export type QueryBlockchainsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BlockchainOrder>;
  where?: InputMaybe<BlockchainWhereInput>;
};


export type QueryConnectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ConnectionOrder>;
  where?: InputMaybe<ConnectionWhereInput>;
};


export type QueryCryptocurrenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CryptocurrencyOrder>;
  where?: InputMaybe<CryptocurrencyWhereInput>;
};


export type QueryDailyAssetPricesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DailyAssetPriceOrder>;
  where?: InputMaybe<DailyAssetPriceWhereInput>;
};


export type QueryExchangesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ExchangeOrder>;
  where?: InputMaybe<ExchangeWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryPortfoliosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PortfolioOrder>;
  where?: InputMaybe<PortfolioWhereInput>;
};


export type QuerySourceTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SourceTypeOrder>;
  where?: InputMaybe<SourceTypeWhereInput>;
};


export type QuerySourcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SourceOrder>;
  where?: InputMaybe<SourceWhereInput>;
};


export type QueryStaffAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StaffAccountOrder>;
  where?: InputMaybe<StaffAccountWhereInput>;
};


export type QueryTransactionTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionTypeOrder>;
  where?: InputMaybe<TransactionTypeWhereInput>;
};


export type QueryTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionOrder>;
  where?: InputMaybe<TransactionWhereInput>;
};

export type Session = {
  __typename?: 'Session';
  authRoles: Array<AuthRoleValue>;
  token: Scalars['SessionToken'];
  userID: Scalars['ID'];
};

export type Source = Node & {
  __typename?: 'Source';
  connections?: Maybe<Array<Connection>>;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  icon?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  sourceType: SourceType;
  updatedAt: Scalars['Time'];
};

/** A connection to a list of items. */
export type SourceConnection = {
  __typename?: 'SourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SourceEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SourceEdge = {
  __typename?: 'SourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Source>;
};

/** Ordering options for Source connections */
export type SourceOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Sources. */
  field: SourceOrderField;
};

/** Properties by which Source connections can be ordered. */
export enum SourceOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

export type SourceType = Node & {
  __typename?: 'SourceType';
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  sources: SourceConnection;
  updatedAt: Scalars['Time'];
  value: SourceTypeValue;
};


export type SourceTypeSourcesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SourceOrder>;
};

/** A connection to a list of items. */
export type SourceTypeConnection = {
  __typename?: 'SourceTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SourceTypeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SourceTypeEdge = {
  __typename?: 'SourceTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<SourceType>;
};

/** Ordering options for SourceType connections */
export type SourceTypeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SourceTypes. */
  field: SourceTypeOrderField;
};

/** Properties by which SourceType connections can be ordered. */
export enum SourceTypeOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  SourceTypeValue = 'SOURCE_TYPE_VALUE',
  UpdatedAt = 'UPDATED_AT'
}

/** SourceTypeValue is enum for the field value */
export enum SourceTypeValue {
  Bank = 'BANK',
  CryptocurrencyWallet = 'CRYPTOCURRENCY_WALLET',
  DecentralizedExchange = 'DECENTRALIZED_EXCHANGE',
  Exchange = 'EXCHANGE'
}

/**
 * SourceTypeWhereInput is used for filtering SourceType objects.
 * Input was generated by ent.
 */
export type SourceTypeWhereInput = {
  and?: InputMaybe<Array<SourceTypeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SourceTypeWhereInput>;
  or?: InputMaybe<Array<SourceTypeWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** value field predicates */
  value?: InputMaybe<SourceTypeValue>;
  valueIn?: InputMaybe<Array<SourceTypeValue>>;
  valueNEQ?: InputMaybe<SourceTypeValue>;
  valueNotIn?: InputMaybe<Array<SourceTypeValue>>;
};

/**
 * SourceWhereInput is used for filtering Source objects.
 * Input was generated by ent.
 */
export type SourceWhereInput = {
  and?: InputMaybe<Array<SourceWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** source_type edge predicates */
  hasSourceType?: InputMaybe<Scalars['Boolean']>;
  hasSourceTypeWith?: InputMaybe<Array<SourceTypeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<SourceWhereInput>;
  or?: InputMaybe<Array<SourceWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type StaffAccount = Node & {
  __typename?: 'StaffAccount';
  authRoles: AuthRoleConnection;
  authType: AuthType;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  email: Scalars['String'];
  emailConfirmed: Scalars['Boolean'];
  id: Scalars['ID'];
  nickname: Scalars['String'];
  passwordUpdatedAt?: Maybe<Scalars['Time']>;
  updatedAt: Scalars['Time'];
};


export type StaffAccountAuthRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AuthRoleOrder>;
  where?: InputMaybe<AuthRoleWhereInput>;
};

/** A connection to a list of items. */
export type StaffAccountConnection = {
  __typename?: 'StaffAccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StaffAccountEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type StaffAccountEdge = {
  __typename?: 'StaffAccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<StaffAccount>;
};

/** Ordering options for StaffAccount connections */
export type StaffAccountOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order StaffAccounts. */
  field: StaffAccountOrderField;
};

/** Properties by which StaffAccount connections can be ordered. */
export enum StaffAccountOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  PasswordUpdatedAt = 'PASSWORD_UPDATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * StaffAccountWhereInput is used for filtering StaffAccount objects.
 * Input was generated by ent.
 */
export type StaffAccountWhereInput = {
  and?: InputMaybe<Array<StaffAccountWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  /** email_confirmed field predicates */
  emailConfirmed?: InputMaybe<Scalars['Boolean']>;
  emailConfirmedNEQ?: InputMaybe<Scalars['Boolean']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** auth_roles edge predicates */
  hasAuthRoles?: InputMaybe<Scalars['Boolean']>;
  hasAuthRolesWith?: InputMaybe<Array<AuthRoleWhereInput>>;
  /** auth_type edge predicates */
  hasAuthType?: InputMaybe<Scalars['Boolean']>;
  hasAuthTypeWith?: InputMaybe<Array<AuthTypeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** nickname field predicates */
  nickname?: InputMaybe<Scalars['String']>;
  nicknameContains?: InputMaybe<Scalars['String']>;
  nicknameContainsFold?: InputMaybe<Scalars['String']>;
  nicknameEqualFold?: InputMaybe<Scalars['String']>;
  nicknameGT?: InputMaybe<Scalars['String']>;
  nicknameGTE?: InputMaybe<Scalars['String']>;
  nicknameHasPrefix?: InputMaybe<Scalars['String']>;
  nicknameHasSuffix?: InputMaybe<Scalars['String']>;
  nicknameIn?: InputMaybe<Array<Scalars['String']>>;
  nicknameLT?: InputMaybe<Scalars['String']>;
  nicknameLTE?: InputMaybe<Scalars['String']>;
  nicknameNEQ?: InputMaybe<Scalars['String']>;
  nicknameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<StaffAccountWhereInput>;
  or?: InputMaybe<Array<StaffAccountWhereInput>>;
  /** password_updated_at field predicates */
  passwordUpdatedAt?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtGT?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtGTE?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  passwordUpdatedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  passwordUpdatedAtLT?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtLTE?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtNEQ?: InputMaybe<Scalars['Time']>;
  passwordUpdatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  passwordUpdatedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Transaction = Node & {
  __typename?: 'Transaction';
  baseAsset: Asset;
  baseAssetID: Scalars['ID'];
  blockchain?: Maybe<Blockchain>;
  blockchainID?: Maybe<Scalars['ID']>;
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  exchange: Exchange;
  exchangeID: Scalars['ID'];
  id: Scalars['ID'];
  portfolio: Portfolio;
  portfolioID: Scalars['ID'];
  pricePerUnit: Scalars['Float'];
  quoteAsset?: Maybe<Asset>;
  quoteAssetID?: Maybe<Scalars['ID']>;
  time: Scalars['Time'];
  transactionType: TransactionType;
  units: Scalars['Int'];
  updatedAt: Scalars['Time'];
};

/** A connection to a list of items. */
export type TransactionConnection = {
  __typename?: 'TransactionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TransactionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type TransactionEdge = {
  __typename?: 'TransactionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Transaction>;
};

/** Ordering options for Transaction connections */
export type TransactionOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Transactions. */
  field: TransactionOrderField;
};

/** Properties by which Transaction connections can be ordered. */
export enum TransactionOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type TransactionType = Node & {
  __typename?: 'TransactionType';
  createdAt: Scalars['Time'];
  deletedAt?: Maybe<Scalars['Time']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  updatedAt: Scalars['Time'];
  value: TransactionTypeValue;
};

/** A connection to a list of items. */
export type TransactionTypeConnection = {
  __typename?: 'TransactionTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TransactionTypeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type TransactionTypeEdge = {
  __typename?: 'TransactionTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<TransactionType>;
};

/** Ordering options for TransactionType connections */
export type TransactionTypeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order TransactionTypes. */
  field: TransactionTypeOrderField;
};

/** Properties by which TransactionType connections can be ordered. */
export enum TransactionTypeOrderField {
  CreatedAt = 'CREATED_AT',
  DeletedAt = 'DELETED_AT',
  TransactionTypeValue = 'TRANSACTION_TYPE_VALUE',
  UpdatedAt = 'UPDATED_AT'
}

/** TransactionTypeValue is enum for the field value */
export enum TransactionTypeValue {
  Buy = 'BUY',
  DividendIncome = 'DIVIDEND_INCOME',
  RentIncome = 'RENT_INCOME',
  RentPayment = 'RENT_PAYMENT',
  Sell = 'SELL',
  Stake = 'STAKE',
  StockDividend = 'STOCK_DIVIDEND',
  Swap = 'SWAP'
}

/**
 * TransactionTypeWhereInput is used for filtering TransactionType objects.
 * Input was generated by ent.
 */
export type TransactionTypeWhereInput = {
  and?: InputMaybe<Array<TransactionTypeWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<TransactionTypeWhereInput>;
  or?: InputMaybe<Array<TransactionTypeWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** value field predicates */
  value?: InputMaybe<TransactionTypeValue>;
  valueIn?: InputMaybe<Array<TransactionTypeValue>>;
  valueNEQ?: InputMaybe<TransactionTypeValue>;
  valueNotIn?: InputMaybe<Array<TransactionTypeValue>>;
};

/**
 * TransactionWhereInput is used for filtering Transaction objects.
 * Input was generated by ent.
 */
export type TransactionWhereInput = {
  and?: InputMaybe<Array<TransactionWhereInput>>;
  /** base_asset_id field predicates */
  baseAssetID?: InputMaybe<Scalars['ID']>;
  baseAssetIDContains?: InputMaybe<Scalars['ID']>;
  baseAssetIDContainsFold?: InputMaybe<Scalars['ID']>;
  baseAssetIDEqualFold?: InputMaybe<Scalars['ID']>;
  baseAssetIDGT?: InputMaybe<Scalars['ID']>;
  baseAssetIDGTE?: InputMaybe<Scalars['ID']>;
  baseAssetIDHasPrefix?: InputMaybe<Scalars['ID']>;
  baseAssetIDHasSuffix?: InputMaybe<Scalars['ID']>;
  baseAssetIDIn?: InputMaybe<Array<Scalars['ID']>>;
  baseAssetIDLT?: InputMaybe<Scalars['ID']>;
  baseAssetIDLTE?: InputMaybe<Scalars['ID']>;
  baseAssetIDNEQ?: InputMaybe<Scalars['ID']>;
  baseAssetIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** blockchain_id field predicates */
  blockchainID?: InputMaybe<Scalars['ID']>;
  blockchainIDContains?: InputMaybe<Scalars['ID']>;
  blockchainIDContainsFold?: InputMaybe<Scalars['ID']>;
  blockchainIDEqualFold?: InputMaybe<Scalars['ID']>;
  blockchainIDGT?: InputMaybe<Scalars['ID']>;
  blockchainIDGTE?: InputMaybe<Scalars['ID']>;
  blockchainIDHasPrefix?: InputMaybe<Scalars['ID']>;
  blockchainIDHasSuffix?: InputMaybe<Scalars['ID']>;
  blockchainIDIn?: InputMaybe<Array<Scalars['ID']>>;
  blockchainIDIsNil?: InputMaybe<Scalars['Boolean']>;
  blockchainIDLT?: InputMaybe<Scalars['ID']>;
  blockchainIDLTE?: InputMaybe<Scalars['ID']>;
  blockchainIDNEQ?: InputMaybe<Scalars['ID']>;
  blockchainIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  blockchainIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']>;
  deletedAtGT?: InputMaybe<Scalars['Time']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  deletedAtLT?: InputMaybe<Scalars['Time']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** exchange_id field predicates */
  exchangeID?: InputMaybe<Scalars['ID']>;
  exchangeIDContains?: InputMaybe<Scalars['ID']>;
  exchangeIDContainsFold?: InputMaybe<Scalars['ID']>;
  exchangeIDEqualFold?: InputMaybe<Scalars['ID']>;
  exchangeIDGT?: InputMaybe<Scalars['ID']>;
  exchangeIDGTE?: InputMaybe<Scalars['ID']>;
  exchangeIDHasPrefix?: InputMaybe<Scalars['ID']>;
  exchangeIDHasSuffix?: InputMaybe<Scalars['ID']>;
  exchangeIDIn?: InputMaybe<Array<Scalars['ID']>>;
  exchangeIDLT?: InputMaybe<Scalars['ID']>;
  exchangeIDLTE?: InputMaybe<Scalars['ID']>;
  exchangeIDNEQ?: InputMaybe<Scalars['ID']>;
  exchangeIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** base_asset edge predicates */
  hasBaseAsset?: InputMaybe<Scalars['Boolean']>;
  hasBaseAssetWith?: InputMaybe<Array<AssetWhereInput>>;
  /** blockchain edge predicates */
  hasBlockchain?: InputMaybe<Scalars['Boolean']>;
  hasBlockchainWith?: InputMaybe<Array<BlockchainWhereInput>>;
  /** exchange edge predicates */
  hasExchange?: InputMaybe<Scalars['Boolean']>;
  hasExchangeWith?: InputMaybe<Array<ExchangeWhereInput>>;
  /** portfolio edge predicates */
  hasPortfolio?: InputMaybe<Scalars['Boolean']>;
  hasPortfolioWith?: InputMaybe<Array<PortfolioWhereInput>>;
  /** quote_asset edge predicates */
  hasQuoteAsset?: InputMaybe<Scalars['Boolean']>;
  hasQuoteAssetWith?: InputMaybe<Array<AssetWhereInput>>;
  /** transaction_type edge predicates */
  hasTransactionType?: InputMaybe<Scalars['Boolean']>;
  hasTransactionTypeWith?: InputMaybe<Array<TransactionTypeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<TransactionWhereInput>;
  or?: InputMaybe<Array<TransactionWhereInput>>;
  /** portfolio_id field predicates */
  portfolioID?: InputMaybe<Scalars['ID']>;
  portfolioIDContains?: InputMaybe<Scalars['ID']>;
  portfolioIDContainsFold?: InputMaybe<Scalars['ID']>;
  portfolioIDEqualFold?: InputMaybe<Scalars['ID']>;
  portfolioIDGT?: InputMaybe<Scalars['ID']>;
  portfolioIDGTE?: InputMaybe<Scalars['ID']>;
  portfolioIDHasPrefix?: InputMaybe<Scalars['ID']>;
  portfolioIDHasSuffix?: InputMaybe<Scalars['ID']>;
  portfolioIDIn?: InputMaybe<Array<Scalars['ID']>>;
  portfolioIDLT?: InputMaybe<Scalars['ID']>;
  portfolioIDLTE?: InputMaybe<Scalars['ID']>;
  portfolioIDNEQ?: InputMaybe<Scalars['ID']>;
  portfolioIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** price_per_unit field predicates */
  pricePerUnit?: InputMaybe<Scalars['Float']>;
  pricePerUnitGT?: InputMaybe<Scalars['Float']>;
  pricePerUnitGTE?: InputMaybe<Scalars['Float']>;
  pricePerUnitIn?: InputMaybe<Array<Scalars['Float']>>;
  pricePerUnitLT?: InputMaybe<Scalars['Float']>;
  pricePerUnitLTE?: InputMaybe<Scalars['Float']>;
  pricePerUnitNEQ?: InputMaybe<Scalars['Float']>;
  pricePerUnitNotIn?: InputMaybe<Array<Scalars['Float']>>;
  /** quote_asset_id field predicates */
  quoteAssetID?: InputMaybe<Scalars['ID']>;
  quoteAssetIDContains?: InputMaybe<Scalars['ID']>;
  quoteAssetIDContainsFold?: InputMaybe<Scalars['ID']>;
  quoteAssetIDEqualFold?: InputMaybe<Scalars['ID']>;
  quoteAssetIDGT?: InputMaybe<Scalars['ID']>;
  quoteAssetIDGTE?: InputMaybe<Scalars['ID']>;
  quoteAssetIDHasPrefix?: InputMaybe<Scalars['ID']>;
  quoteAssetIDHasSuffix?: InputMaybe<Scalars['ID']>;
  quoteAssetIDIn?: InputMaybe<Array<Scalars['ID']>>;
  quoteAssetIDIsNil?: InputMaybe<Scalars['Boolean']>;
  quoteAssetIDLT?: InputMaybe<Scalars['ID']>;
  quoteAssetIDLTE?: InputMaybe<Scalars['ID']>;
  quoteAssetIDNEQ?: InputMaybe<Scalars['ID']>;
  quoteAssetIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  quoteAssetIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** time field predicates */
  time?: InputMaybe<Scalars['Time']>;
  timeGT?: InputMaybe<Scalars['Time']>;
  timeGTE?: InputMaybe<Scalars['Time']>;
  timeIn?: InputMaybe<Array<Scalars['Time']>>;
  timeLT?: InputMaybe<Scalars['Time']>;
  timeLTE?: InputMaybe<Scalars['Time']>;
  timeNEQ?: InputMaybe<Scalars['Time']>;
  timeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** units field predicates */
  units?: InputMaybe<Scalars['Int']>;
  unitsGT?: InputMaybe<Scalars['Int']>;
  unitsGTE?: InputMaybe<Scalars['Int']>;
  unitsIn?: InputMaybe<Array<Scalars['Int']>>;
  unitsLT?: InputMaybe<Scalars['Int']>;
  unitsLTE?: InputMaybe<Scalars['Int']>;
  unitsNEQ?: InputMaybe<Scalars['Int']>;
  unitsNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

/**
 * UpdateAccountInput is used for update Account object.
 * Input was generated by ent.
 */
export type UpdateAccountInput = {
  addAuthRoleIDs?: InputMaybe<Array<Scalars['ID']>>;
  addFriendIDs?: InputMaybe<Array<Scalars['ID']>>;
  authTypeID?: InputMaybe<Scalars['ID']>;
  clearAuthType?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearPassword?: InputMaybe<Scalars['Boolean']>;
  clearProfilePictureURL?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  email?: InputMaybe<Scalars['String']>;
  emailConfirmed?: InputMaybe<Scalars['Boolean']>;
  nickname?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  profilePictureURL?: InputMaybe<Scalars['String']>;
  removeAuthRoleIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeFriendIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateAssetClassInput is used for update AssetClass object.
 * Input was generated by ent.
 */
export type UpdateAssetClassInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<AssetClassValue>;
};

/**
 * UpdateAssetInput is used for update Asset object.
 * Input was generated by ent.
 */
export type UpdateAssetInput = {
  assetClassID?: InputMaybe<Scalars['ID']>;
  clearAssetClass?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateAuthRoleInput is used for update AuthRole object.
 * Input was generated by ent.
 */
export type UpdateAuthRoleInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<AuthRoleValue>;
};

/**
 * UpdateAuthTypeInput is used for update AuthType object.
 * Input was generated by ent.
 */
export type UpdateAuthTypeInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<AuthTypeValue>;
};

/**
 * UpdateBlockchainInput is used for update Blockchain object.
 * Input was generated by ent.
 */
export type UpdateBlockchainInput = {
  chainID?: InputMaybe<Scalars['Int']>;
  clearChainID?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearIcon?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  symbol?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateConnectionInput is used for update Connection object.
 * Input was generated by ent.
 */
export type UpdateConnectionInput = {
  accessToken?: InputMaybe<Scalars['String']>;
  addPortfolioIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearRefreshToken?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  name?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  removePortfolioIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateCryptocurrencyInput is used for update Cryptocurrency object.
 * Input was generated by ent.
 */
export type UpdateCryptocurrencyInput = {
  addBlockchainIDs?: InputMaybe<Array<Scalars['ID']>>;
  assetID?: InputMaybe<Scalars['ID']>;
  clearAsset?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearIcon?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  /** A url to the image icon for this cryptocurrency. */
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  removeBlockchainIDs?: InputMaybe<Array<Scalars['ID']>>;
  symbol?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateDailyAssetPriceInput is used for update DailyAssetPrice object.
 * Input was generated by ent.
 */
export type UpdateDailyAssetPriceInput = {
  adjustedClose?: InputMaybe<Scalars['Float']>;
  assetID?: InputMaybe<Scalars['ID']>;
  clearAsset?: InputMaybe<Scalars['Boolean']>;
  clearClose?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearHigh?: InputMaybe<Scalars['Boolean']>;
  clearLow?: InputMaybe<Scalars['Boolean']>;
  clearOpen?: InputMaybe<Scalars['Boolean']>;
  close?: InputMaybe<Scalars['Float']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  high?: InputMaybe<Scalars['Float']>;
  low?: InputMaybe<Scalars['Float']>;
  open?: InputMaybe<Scalars['Float']>;
  time?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateExchangeInput is used for update Exchange object.
 * Input was generated by ent.
 */
export type UpdateExchangeInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearIcon?: InputMaybe<Scalars['Boolean']>;
  clearURL?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  /** A url to the exchange site. */
  url?: InputMaybe<Scalars['String']>;
};

/**
 * UpdatePortfolioInput is used for update Portfolio object.
 * Input was generated by ent.
 */
export type UpdatePortfolioInput = {
  addConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  /** Whether this portfolio is visible to others. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Whether this portfolio is visible to the owner. */
  isVisible?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  removeConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateSourceInput is used for update Source object.
 * Input was generated by ent.
 */
export type UpdateSourceInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearIcon?: InputMaybe<Scalars['Boolean']>;
  clearSourceType?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  sourceTypeID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateSourceTypeInput is used for update SourceType object.
 * Input was generated by ent.
 */
export type UpdateSourceTypeInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<SourceTypeValue>;
};

/**
 * UpdateStaffAccountInput is used for update StaffAccount object.
 * Input was generated by ent.
 */
export type UpdateStaffAccountInput = {
  addAuthRoleIDs?: InputMaybe<Array<Scalars['ID']>>;
  authTypeID?: InputMaybe<Scalars['ID']>;
  clearAuthType?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearPassword?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  email?: InputMaybe<Scalars['String']>;
  emailConfirmed?: InputMaybe<Scalars['Boolean']>;
  nickname?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  removeAuthRoleIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateTransactionInput is used for update Transaction object.
 * Input was generated by ent.
 */
export type UpdateTransactionInput = {
  baseAssetID?: InputMaybe<Scalars['ID']>;
  blockchainID?: InputMaybe<Scalars['ID']>;
  clearBaseAsset?: InputMaybe<Scalars['Boolean']>;
  clearBlockchain?: InputMaybe<Scalars['Boolean']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearExchange?: InputMaybe<Scalars['Boolean']>;
  clearPortfolio?: InputMaybe<Scalars['Boolean']>;
  clearQuoteAsset?: InputMaybe<Scalars['Boolean']>;
  clearTransactionType?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  exchangeID?: InputMaybe<Scalars['ID']>;
  portfolioID?: InputMaybe<Scalars['ID']>;
  pricePerUnit?: InputMaybe<Scalars['Float']>;
  quoteAssetID?: InputMaybe<Scalars['ID']>;
  time?: InputMaybe<Scalars['Time']>;
  transactionTypeID?: InputMaybe<Scalars['ID']>;
  units?: InputMaybe<Scalars['Int']>;
};

/**
 * UpdateTransactionTypeInput is used for update TransactionType object.
 * Input was generated by ent.
 */
export type UpdateTransactionTypeInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  deletedAt?: InputMaybe<Scalars['Time']>;
  description?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<TransactionTypeValue>;
};

export type GetAccountByIdQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type GetAccountByIdQuery = { __typename?: 'Query', accounts: { __typename?: 'AccountConnection', edges?: Array<{ __typename?: 'AccountEdge', node?: { __typename?: 'Account', id: string, nickname: string, email: string, emailConfirmed: boolean, profilePictureURL?: string | null, passwordUpdatedAt?: any | null, authType: { __typename?: 'AuthType', id: string, value: AuthTypeValue, description?: string | null }, authRoles: { __typename?: 'AuthRoleConnection', edges?: Array<{ __typename?: 'AuthRoleEdge', node?: { __typename?: 'AuthRole', id: string, value: AuthRoleValue, description?: string | null } | null } | null> | null }, friends: { __typename?: 'AccountConnection', edges?: Array<{ __typename?: 'AccountEdge', node?: { __typename?: 'Account', id: string, nickname: string } | null } | null> | null }, portfolios: { __typename?: 'PortfolioConnection', edges?: Array<{ __typename?: 'PortfolioEdge', node?: { __typename?: 'Portfolio', id: string, name: string } | null } | null> | null }, connections: { __typename?: 'ConnectionConnection', edges?: Array<{ __typename?: 'ConnectionEdge', node?: { __typename?: 'Connection', name: string, accessToken: string } | null } | null> | null } } | null } | null> | null } };

export type CreateAccountMutationVariables = Exact<{
  input: CreateAccountInput;
}>;


export type CreateAccountMutation = { __typename?: 'Mutation', createAccount: { __typename?: 'CreateAccountPayload', account: { __typename?: 'Account', id: string, email: string, emailConfirmed: boolean, passwordUpdatedAt?: any | null, authType: { __typename?: 'AuthType', id: string, value: AuthTypeValue } }, session: { __typename?: 'Session', token: any, userID: string, authRoles: Array<AuthRoleValue> } } };

export type LoginToAccountMutationVariables = Exact<{
  input: LoginToAccountInput;
}>;


export type LoginToAccountMutation = { __typename?: 'Mutation', loginToAccount: { __typename?: 'LoginToAccountPayload', account: { __typename?: 'Account', id: string, email: string, emailConfirmed: boolean, passwordUpdatedAt?: any | null, authType: { __typename?: 'AuthType', id: string, value: AuthTypeValue } }, session: { __typename?: 'Session', token: any, userID: string, authRoles: Array<AuthRoleValue> } } };

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = { __typename?: 'Mutation', logout?: any | null };

export type CreateConnectionMutationVariables = Exact<{
  input: CreateConnectionInput;
}>;


export type CreateConnectionMutation = { __typename?: 'Mutation', createConnection: { __typename?: 'Connection', id: string, name: string, accessToken: string, refreshToken?: string | null, source: { __typename?: 'Source', id: string, name: string, icon?: string | null, sourceType: { __typename?: 'SourceType', id: string, value: SourceTypeValue } } } };

export type InitializeDataQueryVariables = Exact<{ [key: string]: never; }>;


export type InitializeDataQuery = { __typename?: 'Query', assetClasses: { __typename?: 'AssetClassConnection', edges?: Array<{ __typename?: 'AssetClassEdge', node?: { __typename?: 'AssetClass', id: string, value: AssetClassValue } | null } | null> | null }, authRoles: { __typename?: 'AuthRoleConnection', edges?: Array<{ __typename?: 'AuthRoleEdge', node?: { __typename?: 'AuthRole', id: string, value: AuthRoleValue } | null } | null> | null }, authTypes: { __typename?: 'AuthTypeConnection', edges?: Array<{ __typename?: 'AuthTypeEdge', node?: { __typename?: 'AuthType', id: string, value: AuthTypeValue } | null } | null> | null }, sourceTypes: { __typename?: 'SourceTypeConnection', edges?: Array<{ __typename?: 'SourceTypeEdge', node?: { __typename?: 'SourceType', id: string, value: SourceTypeValue } | null } | null> | null }, transactionTypes: { __typename?: 'TransactionTypeConnection', edges?: Array<{ __typename?: 'TransactionTypeEdge', node?: { __typename?: 'TransactionType', id: string, value: TransactionTypeValue } | null } | null> | null }, sources: { __typename?: 'SourceConnection', edges?: Array<{ __typename?: 'SourceEdge', node?: { __typename?: 'Source', id: string, name: string, icon?: string | null, sourceType: { __typename?: 'SourceType', id: string, value: SourceTypeValue } } | null } | null> | null } };

export type GetAccountPortfoliosQueryVariables = Exact<{
  userID: Scalars['ID'];
}>;


export type GetAccountPortfoliosQuery = { __typename?: 'Query', portfolios: { __typename?: 'PortfolioConnection', edges?: Array<{ __typename?: 'PortfolioEdge', node?: { __typename?: 'Portfolio', id: string, name: string } | null } | null> | null } };


export const GetAccountByIdDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetAccountByID"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"accounts"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"nickname"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"emailConfirmed"}},{"kind":"Field","name":{"kind":"Name","value":"profilePictureURL"}},{"kind":"Field","name":{"kind":"Name","value":"passwordUpdatedAt"}},{"kind":"Field","name":{"kind":"Name","value":"authType"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}},{"kind":"Field","name":{"kind":"Name","value":"authRoles"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"friends"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"nickname"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"portfolios"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"connections"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"accessToken"}}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetAccountByIdQuery, GetAccountByIdQueryVariables>;
export const CreateAccountDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateAccount"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateAccountInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createAccount"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"account"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"emailConfirmed"}},{"kind":"Field","name":{"kind":"Name","value":"passwordUpdatedAt"}},{"kind":"Field","name":{"kind":"Name","value":"authType"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"session"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}},{"kind":"Field","name":{"kind":"Name","value":"userID"}},{"kind":"Field","name":{"kind":"Name","value":"authRoles"}}]}}]}}]}}]} as unknown as DocumentNode<CreateAccountMutation, CreateAccountMutationVariables>;
export const LoginToAccountDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"LoginToAccount"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"LoginToAccountInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"loginToAccount"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"account"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"email"}},{"kind":"Field","name":{"kind":"Name","value":"emailConfirmed"}},{"kind":"Field","name":{"kind":"Name","value":"passwordUpdatedAt"}},{"kind":"Field","name":{"kind":"Name","value":"authType"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"session"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"token"}},{"kind":"Field","name":{"kind":"Name","value":"userID"}},{"kind":"Field","name":{"kind":"Name","value":"authRoles"}}]}}]}}]}}]} as unknown as DocumentNode<LoginToAccountMutation, LoginToAccountMutationVariables>;
export const LogoutDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"Logout"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"logout"}}]}}]} as unknown as DocumentNode<LogoutMutation, LogoutMutationVariables>;
export const CreateConnectionDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateConnection"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateConnectionInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createConnection"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"accessToken"}},{"kind":"Field","name":{"kind":"Name","value":"refreshToken"}},{"kind":"Field","name":{"kind":"Name","value":"source"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"icon"}},{"kind":"Field","name":{"kind":"Name","value":"sourceType"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}}]}}]} as unknown as DocumentNode<CreateConnectionMutation, CreateConnectionMutationVariables>;
export const InitializeDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"InitializeData"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"assetClasses"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"authRoles"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"authTypes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"sourceTypes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"transactionTypes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"sources"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"icon"}},{"kind":"Field","name":{"kind":"Name","value":"sourceType"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"value"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<InitializeDataQuery, InitializeDataQueryVariables>;
export const GetAccountPortfoliosDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetAccountPortfolios"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"userID"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"portfolios"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"userID"}}},{"kind":"ObjectField","name":{"kind":"Name","value":"isVisible"},"value":{"kind":"BooleanValue","value":true}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetAccountPortfoliosQuery, GetAccountPortfoliosQueryVariables>;